"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeChangelog = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const getPackageChangelogs_1 = require("./getPackageChangelogs");
const renderChangelog_1 = require("./renderChangelog");
const renderJsonChangelog_1 = require("./renderJsonChangelog");
const isPathIncluded_1 = require("../monorepo/isPathIncluded");
const mergeChangelogs_1 = require("./mergeChangelogs");
async function writeChangelog(bumpInfo, options) {
    const { packageInfos } = bumpInfo;
    const groupedChangelogDirs = await writeGroupedChangelog(bumpInfo, options);
    // Get changelogs including dependent changes
    const changelogs = (0, getPackageChangelogs_1.getPackageChangelogs)(bumpInfo, options);
    // Write package changelogs.
    // Use a standard for loop here to prevent potentially firing off multiple network requests at once
    // (in case any custom renderers have network requests).
    for (const pkg of Object.keys(changelogs)) {
        const packagePath = path_1.default.dirname(packageInfos[pkg].packageJsonPath);
        if (!groupedChangelogDirs.includes(packagePath)) {
            await writeChangelogFiles({
                options,
                newVersionChangelog: changelogs[pkg],
                changelogPath: packagePath,
                isGrouped: false,
            });
        }
    }
}
exports.writeChangelog = writeChangelog;
/**
 * Write grouped changelogs.
 * @returns The list of directories where grouped changelogs were written.
 */
async function writeGroupedChangelog(bumpInfo, options) {
    const { changeFileChangeInfos, calculatedChangeTypes, packageInfos } = bumpInfo;
    // Get the changelog groups with absolute paths.
    const changelogGroups = options.changelog?.groups?.map(({ changelogPath, ...rest }) => ({
        ...rest,
        changelogAbsDir: path_1.default.resolve(options.path, changelogPath),
    }));
    if (!changelogGroups?.length) {
        return [];
    }
    // Get changelogs without dependency bump entries
    // (do NOT spread the bump info here!)
    const changelogs = (0, getPackageChangelogs_1.getPackageChangelogs)({ changeFileChangeInfos, calculatedChangeTypes, packageInfos }, options);
    const groupedChangelogs = {};
    // Validate groups and initialize groupedChangelogs
    for (const { masterPackageName, changelogAbsDir } of changelogGroups) {
        const masterPackage = packageInfos[masterPackageName];
        if (!masterPackage) {
            console.warn(`master package ${masterPackageName} does not exist.`);
            continue;
        }
        if (!fs_extra_1.default.existsSync(changelogAbsDir)) {
            console.warn(`changelog path ${changelogAbsDir} does not exist.`);
            continue;
        }
        groupedChangelogs[changelogAbsDir] = { masterPackage, changelogs: [] };
    }
    // Put changelogs into groups
    for (const pkg of Object.keys(changelogs)) {
        const packagePath = path_1.default.dirname(packageInfos[pkg].packageJsonPath);
        const relativePath = path_1.default.relative(options.path, packagePath);
        for (const group of changelogGroups) {
            const isInGroup = (0, isPathIncluded_1.isPathIncluded)(relativePath, group.include, group.exclude);
            if (isInGroup) {
                groupedChangelogs[group.changelogAbsDir].changelogs.push(changelogs[pkg]);
            }
        }
    }
    // Write each grouped changelog if it's not empty
    for (const [changelogAbsDir, { masterPackage, changelogs }] of Object.entries(groupedChangelogs)) {
        const groupedChangelog = (0, mergeChangelogs_1.mergeChangelogs)(changelogs, masterPackage);
        if (groupedChangelog) {
            await writeChangelogFiles({
                options,
                newVersionChangelog: groupedChangelog,
                changelogPath: changelogAbsDir,
                isGrouped: true,
            });
        }
    }
    // Return all the possible grouped changelog directories (even if there was nothing to write).
    // Otherwise if a grouped changelog location overlaps with a package changelog location, and
    // on one publish there are only dependent bump changes for that package (and no changes for
    // other packages in the group), we'd get the package changelog updates with dependent bumps
    // added to the otherwise-grouped changelog file.
    return Object.keys(groupedChangelogs);
}
async function writeChangelogFiles(params) {
    const { options, newVersionChangelog, changelogPath, isGrouped } = params;
    let previousJson;
    // Update CHANGELOG.json
    if (options.generateChangelog === true || options.generateChangelog === 'json') {
        const changelogJsonFile = path_1.default.join(changelogPath, 'CHANGELOG.json');
        try {
            previousJson = fs_extra_1.default.existsSync(changelogJsonFile) ? fs_extra_1.default.readJSONSync(changelogJsonFile) : undefined;
        }
        catch (e) {
            console.warn(`${changelogJsonFile} is invalid: ${e}`);
        }
        try {
            const nextJson = (0, renderJsonChangelog_1.renderJsonChangelog)(newVersionChangelog, previousJson);
            fs_extra_1.default.writeJSONSync(changelogJsonFile, nextJson, { spaces: 2 });
        }
        catch (e) {
            console.warn(`Problem writing to ${changelogJsonFile}: ${e}`);
        }
    }
    // Update CHANGELOG.md if there are changes of types besides "none"
    if ((options.generateChangelog === true || options.generateChangelog === 'md') &&
        Object.entries(newVersionChangelog.comments).some(([type, comments]) => type !== 'none' && comments?.length)) {
        const changelogFile = path_1.default.join(changelogPath, 'CHANGELOG.md');
        const previousContent = fs_extra_1.default.existsSync(changelogFile) ? fs_extra_1.default.readFileSync(changelogFile).toString() : '';
        const newChangelog = await (0, renderChangelog_1.renderChangelog)({
            previousJson,
            previousContent,
            newVersionChangelog,
            isGrouped,
            changelogOptions: options.changelog || {},
        });
        fs_extra_1.default.writeFileSync(changelogFile, newChangelog);
    }
}
//# sourceMappingURL=writeChangelog.js.map