"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPackageChangelog = exports.defaultRenderers = void 0;
const lodash_1 = __importDefault(require("lodash"));
const changeTypes_1 = require("../changefile/changeTypes");
const groupNames = {
    major: 'Major changes',
    premajor: 'Major changes (pre-release)',
    minor: 'Minor changes',
    preminor: 'Minor changes (pre-release)',
    patch: 'Patches',
    prepatch: 'Patches (pre-release)',
    prerelease: 'Changes',
    none: '', // not used
};
// Skip 'none' changes, then order from major down to prerelease
const changeTypeOrder = changeTypes_1.SortedChangeTypes.slice(1).reverse();
exports.defaultRenderers = {
    renderHeader: _renderHeader,
    renderChangeTypeSection: _renderChangeTypeSection,
    renderChangeTypeHeader: _renderChangeTypeHeader,
    renderEntries: _renderEntries,
    renderEntry: _renderEntry,
};
async function renderPackageChangelog(renderInfo) {
    const { renderHeader, renderChangeTypeSection } = renderInfo.renderers;
    const sections = [await renderHeader(renderInfo)];
    for (const changeType of changeTypeOrder) {
        const section = await renderChangeTypeSection(changeType, renderInfo);
        if (section) {
            sections.push(section);
        }
    }
    return sections.join('\n\n');
}
exports.renderPackageChangelog = renderPackageChangelog;
async function _renderHeader(renderInfo) {
    return `## ${renderInfo.newVersionChangelog.version}\n\n${renderInfo.newVersionChangelog.date.toUTCString()}`;
}
async function _renderChangeTypeSection(changeType, renderInfo) {
    const { renderChangeTypeHeader, renderEntries } = renderInfo.renderers;
    const entries = renderInfo.newVersionChangelog.comments[changeType];
    return entries && entries.length
        ? `${await renderChangeTypeHeader(changeType, renderInfo)}\n\n${await renderEntries(changeType, renderInfo)}`
        : '';
}
async function _renderChangeTypeHeader(changeType) {
    return `### ${groupNames[changeType]}`;
}
async function _renderEntries(changeType, renderInfo) {
    const entries = renderInfo.newVersionChangelog.comments[changeType];
    if (!entries || !entries.length) {
        return '';
    }
    if (renderInfo.isGrouped) {
        const entriesByPackage = lodash_1.default.entries(lodash_1.default.groupBy(entries, entry => entry.package));
        // Use a for loop here (not map) so that if renderEntry does network requests, we don't fire them all at once
        let packagesText = [];
        for (const [pkgName, pkgEntries] of entriesByPackage) {
            const entriesText = (await _renderEntriesBasic(pkgEntries, renderInfo)).map(entry => `  ${entry}`).join('\n');
            packagesText.push(`- \`${pkgName}\`\n${entriesText}`);
        }
        return packagesText.join('\n');
    }
    return (await _renderEntriesBasic(entries, renderInfo)).join('\n');
}
async function _renderEntriesBasic(entries, renderInfo) {
    // Use a for loop here (not map) so that if renderEntry does network requests, we don't fire them all at once
    let results = [];
    for (const entry of entries) {
        results.push(await renderInfo.renderers.renderEntry(entry, renderInfo));
    }
    return results;
}
async function _renderEntry(entry, renderInfo) {
    if (entry.author === 'beachball') {
        return `- ${entry.comment}`;
    }
    return `- ${entry.comment} (${entry.author})`;
}
//# sourceMappingURL=renderPackageChangelog.js.map