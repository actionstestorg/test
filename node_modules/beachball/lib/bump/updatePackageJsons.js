"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePackageJsons = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const PackageInfo_1 = require("../types/PackageInfo");
/**
 * Update package.json files for modified packages after bumping.
 */
function updatePackageJsons(modifiedPackages, packageInfos) {
    for (const pkgName of modifiedPackages) {
        const info = packageInfos[pkgName];
        if (!fs_extra_1.default.existsSync(info.packageJsonPath)) {
            // rare case in highly active monorepos where a package might have been deleted in main
            console.warn(`Skipping ${pkgName} since package.json does not exist`);
            continue;
        }
        const packageJson = fs_extra_1.default.readJSONSync(info.packageJsonPath);
        if (!info.private) {
            packageJson.version = info.version;
        }
        for (const depKind of PackageInfo_1.consideredDependencies) {
            // updatedDeps contains all of the dependencies in the bump info since the beginning of a build job
            const updatedDeps = info[depKind] || {};
            // to be cautious, only update internal && modifiedPackages, since some other dependency
            // changes could have occurred since the beginning of the build job and the next merge step
            // would overwrite those incorrectly!
            for (const [dep, updatedVersion] of Object.entries(updatedDeps)) {
                if (modifiedPackages.has(dep) && packageJson[depKind]?.[dep]) {
                    packageJson[depKind][dep] = updatedVersion;
                }
            }
        }
        fs_extra_1.default.writeJSONSync(info.packageJsonPath, packageJson, { spaces: 2 });
    }
}
exports.updatePackageJsons = updatePackageJsons;
//# sourceMappingURL=updatePackageJsons.js.map