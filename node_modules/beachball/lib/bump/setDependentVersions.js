"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDependentVersions = void 0;
const PackageInfo_1 = require("../types/PackageInfo");
const bumpMinSemverRange_1 = require("./bumpMinSemverRange");
/**
 * Go through the deps of each package and bump the version range for in-repo deps if needed.
 *
 * **This mutates dep versions in `packageInfos`** as well as returning `dependentChangedBy`.
 */
function setDependentVersions(bumpInfo, options) {
    const { packageInfos, scopedPackages } = bumpInfo;
    const { verbose } = options;
    const dependentChangedBy = {};
    for (const [pkgName, info] of Object.entries(packageInfos)) {
        if (!scopedPackages.has(pkgName)) {
            continue; // out of scope
        }
        for (const depType of PackageInfo_1.consideredDependencies) {
            const deps = info[depType] || {};
            for (const [dep, existingVersionRange] of Object.entries(deps)) {
                const depPackage = packageInfos[dep];
                if (!depPackage) {
                    continue; // external dependency
                }
                const bumpedVersionRange = (0, bumpMinSemverRange_1.bumpMinSemverRange)(depPackage.version, existingVersionRange);
                // TODO: dependent bumps in workspace:*/^/~ ranges will be missed
                // https://github.com/microsoft/beachball/issues/981
                if (existingVersionRange !== bumpedVersionRange) {
                    deps[dep] = bumpedVersionRange;
                    dependentChangedBy[pkgName] ?? (dependentChangedBy[pkgName] = new Set());
                    dependentChangedBy[pkgName].add(dep);
                    if (verbose) {
                        console.log(`${pkgName} needs to be bumped because ${dep} ${existingVersionRange} -> ${bumpedVersionRange}`);
                    }
                }
            }
        }
    }
    return dependentChangedBy;
}
exports.setDependentVersions = setDependentVersions;
//# sourceMappingURL=setDependentVersions.js.map